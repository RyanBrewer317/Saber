//fn test1() -> int {
//  (fn(f) f(7))(fn(n: int) n) // returns 7, the first function literal has type dyn->dyn
//}

// def test2 = (fn(f) f(7))(fn(g: int->int) g(7)) // this typechecks because of dyn, and crashes at runtime

//fn test3() -> int {
//  (fn(f: int->int) f(7))(fn(n: int) n) // returns 7, no magic here
//}

// def test4 = (fn(f: int->int) f(fn(a: int) 2))(fn(n: int) n) // type error here

// use of imports (temporarily broken)
//import main2
//fn test7() -> int {
//  main2.first(main2.id(main2.id)(main2.id(4)), fn(a) 5) // returns `4`, and `fn(a) 5` has type `dyn->int`
//}

// demo of sigma-type nature of function arguments 
// (function types are thought of as `Pi x: Sigma(...). T(x)`)
fn test9(t: type, x: t) -> t {
  x
}

// @-parameters are called compile-time parameters, and get erased before runtime.
//fn zero(@t: type, base: t) -> (t->t)->t {
//  fn(step: t->t) base
//}

//fn succ(@t: type, n: t->(t->t)->t) -> t->(t->t)->t {
//  fn(base: t) fn(step: t->t) step(n(base)(step))
//}

// dependent types work at the moment, as I haven't banned the (*,\square) rule in the PTS yet
fn test10(typelevel_churchbool: Fn(a: type, b: type) type) -> type {
  typelevel_churchbool(int)(int->int)
}

//fn test11() -> inter{x: int->int, y: int} {
//  7
//}

fn main() {
  print(test9(test10(fn(a: type, b: type) a), 7))
}
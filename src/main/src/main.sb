fn test1() -> int {
  (fn(f) f(7))(fn(n: int) n) // returns 7, the first function literal has type dyn->dyn
}

// def test2 = (fn(f) f(7))(fn(g: int->int) g(7)) // this typechecks because of dyn, and crashes at runtime

fn test3() -> int {
  (fn(f: int->int) f(7))(fn(n: int) n) // returns 7, no magic here
}

// def test4 = (fn(f: int->int) f(fn(a: int) 2))(fn(n: int) n) // type error here

// `fn<x, y>(z, w) e` is a function which is called with only the arguments z and w
// the values for x and y are inferred using z and w
// When a normal argument has no type annotation, it is given the dynamic type `dyn`
// When an implicit argument has no type annotation, it is given the type `type`
// Good examples are in main2/main2.sb, and used below

// use of imports (very wip)
fn test7() -> int {
  main2.first(main2.id(main2.id)(main2.id(4)), fn(a) 5) // returns `4`, and `fn(a) 5` has type `dyn->int`
}

// structs and struct types
fn test8(age: int) -> struct{age: int, size: int} {
  {age: age, size: 7}
}

// demo of sigma-type nature of function arguments 
// (function types are always `Pi x: Sigma(...). T(x)`)
fn test9(t: type, x: t) -> t {
  x
}

fn zero[t](base: t) -> (t->t)->t {
  fn(step: t->t) base
}

fn succ[t](n: t->(t->t)->t) -> t->(t->t)->t {
  fn(base: t) fn(step: t->t) step(n(base)(step))
}

// dependent types work at the moment, as I haven't banned the (*,square) rule in the PTS yet
fn test10(x: int) -> type {
  int // there isn't really a way to make use of DT without ADTs, so this is a constant function
}

fn test11() -> inter{x: int->int, y: int} {
  7
}

fn main() {
  print(test9(test10(3), test8(20).size))
}
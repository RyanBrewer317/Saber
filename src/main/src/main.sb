fn test0() -> int {
  print(main2.hi())
}

fn test1() -> int {
  (fn(f) f(7))(fn(n: int) n) // returns 7, the first function literal has type dyn->dyn
}

// def test2 = (fn(f) f(7))(fn(g: int->int) g(7)) // this typechecks because of dyn, and crashes at runtime

fn test3() -> int {
  (fn(f: int->int) f(7))(fn(n: int) n) // returns 7, no magic here
}

// def test4 = (fn(f: int->int) f(fn(a: int) 2))(fn(n: int) n) // type error here

// `fn<x, y>(z, w) e` is a function which is called with only the arguments z and w
// the values for x and y are inferred using z and w
// When a normal argument has no type annotation, it is given the dynamic type `dyn`
// When an implicit argument has no type annotation, it is given the type `type`
fn id[a](x: a) -> a {
  x
}
fn first[a, b](x: a, y: b) -> a {
  x
}
fn test7() -> int {
  first(id(id)(id(4)), fn(a) 5) // returns `4`, and `fn(a) 5` has type `dyn->int`
}

fn main() {
  print(main2.hi())
}